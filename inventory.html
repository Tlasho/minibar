<!DOCTYPE html>
<html>
<head>
<script src="nozoom.js"></script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Minibar - Inventory</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: Arial, sans-serif;
  background: #0b0f1a;
  color: #e5e7eb;
}

.inventory-page {
  padding: 20px;
  min-height: 100vh;
  background: linear-gradient(135deg, #0b0f1a 0%, #1e293b 100%);
}

.inventory-container {
  max-width: 800px;
  margin: 60px auto 0;
  background: rgba(15, 23, 42, 0.9);
  padding: 30px;
  border-radius: 16px;
  border: 2px solid #475569;
}

.inventory-title {
  color: #e5e7eb;
  font-size: 32px;
  margin-bottom: 30px;
  text-align: center;
}

.inventory-controls {
  display: flex;
  gap: 15px;
  margin-bottom: 30px;
  flex-wrap: wrap;
}

.clear-button, .export-button, .sort-button {
  padding: 12px 20px;
  border: none;
  border-radius: 10px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
}

.clear-button {
  background: #ef4444;
  color: white;
}

.clear-button:hover {
  background: #dc2626;
  transform: translateY(-2px);
}

.export-button {
  background: #3b82f6;
  color: white;
}

.export-button:hover {
  background: #2563eb;
  transform: translateY(-2px);
}

.sort-button {
  background: #8b5cf6;
  color: white;
}

.sort-button:hover {
  background: #7c3aed;
  transform: translateY(-2px);
}

.sort-button.active {
  background: #7c3aed;
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
}

.inventory-list {
  background: rgba(30, 41, 59, 0.5);
  border-radius: 12px;
  padding: 20px;
  min-height: 300px;
  max-height: 500px;
  overflow-y: auto;
}

.inventory-room-item {
  background: rgba(15, 23, 42, 0.8);
  padding: 20px;
  margin-bottom: 15px;
  border-radius: 12px;
  border: 2px solid #475569;
  transition: all 0.3s ease;
  cursor: pointer;
  user-select: none;
  position: relative;
  overflow: hidden;
  transform-origin: center;
}

.inventory-room-item::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 0;
  height: 100%;
  background: linear-gradient(90deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.3) 100%);
  transition: width 0.3s ease;
  z-index: 1;
}

.inventory-room-item.swiping-red::before {
  width: 100%;
}

.inventory-room-item.swiping-green::before {
  width: 100%;
  background: linear-gradient(90deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.3) 100%);
}

.inventory-room-item.green {
  background: rgba(16, 185, 129, 0.15);
  border-color: #10b981;
  box-shadow: 0 4px 15px rgba(16, 185, 129, 0.2);
  opacity: 0.8;
}

.inventory-room-item.green .room-number {
  color: #10b981;
  font-weight: bold;
}

.inventory-room-item.green .room-summary {
  color: #a7f3d0;
}

.inventory-room-item.green .checkmark {
  opacity: 1;
  transform: scale(1);
}

.inventory-room-item.red {
  background: rgba(239, 68, 68, 0.15);
  border-color: #ef4444;
  box-shadow: 0 4px 15px rgba(239, 68, 68, 0.2);
}

.inventory-room-item.red .room-number {
  color: #fca5a5;
  font-weight: bold;
}

.inventory-room-item.red .room-summary {
  color: #fecaca;
}

.inventory-room-item.red .checkmark {
  opacity: 1;
  transform: scale(1);
}

.inventory-room-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.room-number {
  color: #60a5fa;
  font-weight: bold;
  font-size: 22px;
  display: flex;
  align-items: center;
  gap: 10px;
  position: relative;
  z-index: 2;
}

.checkmark {
  color: #10b981;
  font-size: 18px;
  opacity: 0;
  transform: scale(0);
  transition: all 0.3s ease;
}

.room-summary {
  color: #cbd5e1;
  font-size: 16px;
  width: 100%;
  position: relative;
  z-index: 2;
}

.product-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}

.product-item {
  background: rgba(30, 41, 59, 0.6);
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #475569;
  font-size: 14px;
  color: #cbd5e1;
  position: relative;
  z-index: 2;
}

.no-inventory {
  text-align: center;
  padding: 40px;
  color: #94a3b8;
}

.back-arrow {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 18px;
  color: #e5e7eb;
  cursor: pointer;
  background: rgba(30, 41, 59, 0.8);
  padding: 10px 15px;
  border-radius: 12px;
  border: 2px solid #475569;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 5px;
  z-index: 100;
  text-decoration: none;
}

.back-arrow:hover {
  background: rgba(51, 65, 85, 0.9);
  transform: translateX(-3px);
}

.swipe-hint {
  text-align: center;
  color: #94a3b8;
  font-size: 14px;
  margin-bottom: 20px;
  padding: 10px;
  background: rgba(30, 41, 59, 0.3);
  border-radius: 8px;
}

.room-count {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(30, 41, 59, 0.8);
  color: #e5e7eb;
  padding: 8px 16px;
  border-radius: 20px;
  border: 2px solid #475569;
  font-size: 14px;
  font-weight: bold;
  z-index: 100;
}

.swipe-feedback {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  padding-left: 20px;
  color: #10b981;
  font-size: 16px;
  font-weight: bold;
  opacity: 0;
  transform: translateX(-20px);
  transition: all 0.3s ease;
  z-index: 1;
  pointer-events: none;
}

.swipe-feedback.red {
  color: #ef4444;
}

.inventory-room-item.swiping-red .swipe-feedback {
  opacity: 1;
  transform: translateX(0);
  color: #ef4444;
}

.inventory-room-item.swiping-green .swipe-feedback {
  opacity: 1;
  transform: translateX(0);
  color: #10b981;
}

.swipe-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 3px;
  background: #ef4444;
  border-radius: 0 0 12px 12px;
  width: 0%;
  transition: width 0.2s ease;
}

.inventory-room-item.swiping-green .swipe-progress {
  background: #10b981;
}

.swipe-info {
  position: absolute;
  bottom: 10px;
  right: 10px;
  font-size: 12px;
  color: #94a3b8;
  z-index: 2;
}

.total-items {
  background: rgba(30, 41, 59, 0.8);
  color: #e5e7eb;
  padding: 8px 16px;
  border-radius: 20px;
  border: 2px solid #475569;
  font-size: 14px;
  margin-top: 15px;
  text-align: center;
  cursor: pointer;
}

.last-updated {
  font-size: 12px;
  color: #94a3b8;
  margin-top: 5px;
}

.sort-indicator {
  display: inline-block;
  margin-left: 10px;
  font-size: 12px;
  color: #8b5cf6;
  background: rgba(139, 92, 246, 0.2);
  padding: 2px 8px;
  border-radius: 12px;
  border: 1px solid #8b5cf6;
}

@media (max-width: 768px) {
  .inventory-container {
    margin-top: 80px;
    padding: 20px;
  }
  
  .inventory-title {
    font-size: 24px;
  }
  
  .room-number {
    font-size: 18px;
  }
  
  .product-item {
    font-size: 12px;
    padding: 4px 8px;
  }
  
  .back-arrow {
    top: 15px;
    left: 15px;
    padding: 8px 12px;
  }
  
  .room-count {
    top: 15px;
    right: 15px;
    font-size: 12px;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideOut {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-20px);
  }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.pulse {
  animation: pulse 0.3s ease;
}
</style>
</head>

<body class="inventory-page">

<a href="main.html" class="back-arrow">‚Üê ·É£·Éô·Éê·Éú</a>

<div class="room-count" id="roomCount">·Éù·Éó·Éê·ÉÆ·Éî·Éë·Éò: 0</div>

<div class="inventory-container">
  <h1 class="inventory-title">üìã ·É®·Éî·Éï·É°·Éî·Éë·Éê</h1>

  
  <div class="inventory-controls">
    <button class="clear-button" id="clearButton">·Éí·Éê·É°·É£·É§·Éó·Éê·Éï·Éî·Éë·Éê</button>
    <button class="export-button" id="exportButton">·Éî·É•·É°·Éû·Éù·É†·É¢·Éò</button>
    <button class="sort-button" id="sortButton">·Éì·Éê·Éö·Éê·Éí·Éî·Éë·Éê</button>
  </div>
  
  <div class="inventory-list" id="inventoryList">
    <!-- Inventory items will be loaded here -->
  </div>
  
  <div class="total-items" onclick="window.location.href='totals.html'" id="totalItems">·É°·É£·Éö ·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò: 0</div>
</div>

<script>
const InventoryManager = {
  getAllInventory() {
    const inventory = localStorage.getItem('minibarInventory');
    return inventory ? JSON.parse(inventory) : {};
  },
  
  getMarkedRooms() {
    const markedRooms = localStorage.getItem('markedRooms');
    return markedRooms ? JSON.parse(markedRooms) : [];
  },
  
  getRedRooms() {
    const redRooms = localStorage.getItem('redRooms');
    return redRooms ? JSON.parse(redRooms) : [];
  },
  
  markRoom(roomNumber, type = 'green') {
    if (type === 'green') {
      // Add to green rooms, remove from red
      const markedRooms = this.getMarkedRooms();
      const redRooms = this.getRedRooms();
      
      if (!markedRooms.includes(roomNumber)) {
        markedRooms.push(roomNumber);
        localStorage.setItem('markedRooms', JSON.stringify(markedRooms));
      }
      
      const redIndex = redRooms.indexOf(roomNumber);
      if (redIndex > -1) {
        redRooms.splice(redIndex, 1);
        localStorage.setItem('redRooms', JSON.stringify(redRooms));
      }
    } else if (type === 'red') {
      // Add to red rooms, remove from green
      const redRooms = this.getRedRooms();
      const markedRooms = this.getMarkedRooms();
      
      if (!redRooms.includes(roomNumber)) {
        redRooms.push(roomNumber);
        localStorage.setItem('redRooms', JSON.stringify(redRooms));
      }
      
      const greenIndex = markedRooms.indexOf(roomNumber);
      if (greenIndex > -1) {
        markedRooms.splice(greenIndex, 1);
        localStorage.setItem('markedRooms', JSON.stringify(markedRooms));
      }
    }
    return true;
  },
  
  unmarkRoom(roomNumber) {
    // Remove from both green and red
    const markedRooms = this.getMarkedRooms();
    const redRooms = this.getRedRooms();
    
    const greenIndex = markedRooms.indexOf(roomNumber);
    if (greenIndex > -1) {
      markedRooms.splice(greenIndex, 1);
      localStorage.setItem('markedRooms', JSON.stringify(markedRooms));
    }
    
    const redIndex = redRooms.indexOf(roomNumber);
    if (redIndex > -1) {
      redRooms.splice(redIndex, 1);
      localStorage.setItem('redRooms', JSON.stringify(redRooms));
    }
    
    return true;
  },
  
  isRoomMarked(roomNumber) {
    const markedRooms = this.getMarkedRooms();
    const redRooms = this.getRedRooms();
    
    if (markedRooms.includes(roomNumber)) return 'green';
    if (redRooms.includes(roomNumber)) return 'red';
    return false;
  },
  
  // In InventoryManager.getAllRoomsSummary() function, add this:
getAllRoomsSummary(sortBy = 'date') {
  const allInventory = this.getAllInventory();
  const markedRooms = this.getMarkedRooms();
  const redRooms = this.getRedRooms();
  const summaries = [];
  let totalProducts = 0;
  
  Object.keys(allInventory).forEach(roomNumber => {
    const roomInventory = allInventory[roomNumber];
    const products = roomInventory.products || {};
    const productItems = [];
    let roomProductCount = 0;
    let hasYellowProducts = false;
    
    Object.keys(products)
      .sort((a, b) => parseInt(a) - parseInt(b))
      .forEach(productId => {
        const product = products[productId];
        if (product.count > 0) {
          // Check if it's a yellow product
          const isYellow = product.type === 'yellow';
          if (isYellow) {
            hasYellowProducts = true;
          }
          
          productItems.push({
            name: product.name,
            count: product.count,
            isYellow: isYellow  // Add this flag
          });
          roomProductCount += product.count;
        }
      });
    
    if (productItems.length > 0) {
      totalProducts += roomProductCount;
      
      let status = 'none';
      if (markedRooms.includes(roomNumber)) status = 'green';
      else if (redRooms.includes(roomNumber)) status = 'red';
      else if (hasYellowProducts) status = 'yellow'; // Add yellow status
      
      summaries.push({
        room: roomNumber,
        products: productItems,
        totalCount: roomProductCount,
        status: status,
        lastUpdated: roomInventory.lastUpdated || new Date().toISOString(),
        timestamp: new Date(roomInventory.lastUpdated || new Date()).getTime()
      });
    }
  });
  
  const sortedSummaries = this.sortSummaries(summaries, sortBy);
  
  return {
    summaries: sortedSummaries,
    totalProducts,
    sortBy
  };
},
  
  sortSummaries(summaries, sortBy) {
    if (sortBy === 'date') {
      return summaries.sort((a, b) => {
        // Put marked rooms at the BOTTOM (green then red, then none on top)
        const statusOrder = { 'none': 0, 'red': 1, 'green': 2 };
        if (statusOrder[a.status] !== statusOrder[b.status]) {
          return statusOrder[a.status] - statusOrder[b.status];
        }
        // Then sort by timestamp (newest first)
        return b.timestamp - a.timestamp;
      });
    } else if (sortBy === 'room') {
      return summaries.sort((a, b) => {
        // Put marked rooms at the BOTTOM
        const statusOrder = { 'none': 0, 'red': 1, 'green': 2 };
        if (statusOrder[a.status] !== statusOrder[b.status]) {
          return statusOrder[a.status] - statusOrder[b.status];
        }
        // Then sort by room number
        return parseInt(a.room) - parseInt(b.room);
      });
    } else if (sortBy === 'products') {
      return summaries.sort((a, b) => {
        // Put marked rooms at the BOTTOM
        const statusOrder = { 'none': 0, 'red': 1, 'green': 2 };
        if (statusOrder[a.status] !== statusOrder[b.status]) {
          return statusOrder[a.status] - statusOrder[b.status];
        }
        // Then sort by product count (highest first)
        return b.totalCount - a.totalCount;
      });
    }
    return summaries;
  },
  
  clearAll() {
    localStorage.setItem('minibarInventory', JSON.stringify({}));
    localStorage.setItem('markedRooms', JSON.stringify([]));
    localStorage.setItem('redRooms', JSON.stringify([]));
    return true;
  },
  
  exportInventory() {
    const allInventory = this.getAllInventory();
    const markedRooms = this.getMarkedRooms();
    const redRooms = this.getRedRooms();
    const exportData = [];
    
    Object.keys(allInventory).forEach(roomNumber => {
      const roomInventory = allInventory[roomNumber];
      const products = roomInventory.products || {};
      const productList = [];
      
      Object.keys(products)
        .sort((a, b) => parseInt(a) - parseInt(b))
        .forEach(productId => {
          const product = products[productId];
          if (product.count > 0) {
            productList.push(`${product.count} ${product.name}`);
          }
        });
      
      if (productList.length > 0) {
        let status = 'None';
        if (markedRooms.includes(roomNumber)) status = 'Green';
        else if (redRooms.includes(roomNumber)) status = 'Red';
        
        exportData.push({
          room: roomNumber,
          products: productList.join(', '),
          status: status,
          date: roomInventory.lastUpdated || new Date().toISOString()
        });
      }
    });
    
    const csvContent = [
      ['Room', 'Products', 'Status', 'Date'],
      ...exportData.map(item => [
        item.room,
        item.products,
        item.status,
        new Date(item.date).toLocaleDateString('ka-GE')
      ])
    ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `minibar_inventory_${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  }
};

document.addEventListener('DOMContentLoaded', function() {
  const inventoryList = document.getElementById('inventoryList');
  const clearButton = document.getElementById('clearButton');
  const exportButton = document.getElementById('exportButton');
  const sortButton = document.getElementById('sortButton');
  const roomCount = document.getElementById('roomCount');
  const totalItems = document.getElementById('totalItems');
  
  // Default sort is 'date' (not 'time')
  let currentSort = localStorage.getItem('inventorySort') || 'date';
  const sortMethods = ['date', 'room', 'products']; // Changed order
  let sortIndex = sortMethods.indexOf(currentSort);
  
  updateSortButton();
  
  function loadInventory() {
    const result = InventoryManager.getAllRoomsSummary(currentSort);
    const { summaries, totalProducts } = result;
    inventoryList.innerHTML = '';
    
    if (summaries.length === 0) {
      inventoryList.innerHTML = `
        <div class="no-inventory">
          <p>·ÉØ·Éî·É†·ÉØ·Éî·É†·Éù·Éë·Éò·Éó ·Éê·É† ·Éì·Éê·Éí·Éò·Éõ·Éê·É¢·Éî·Éë·Éò·Éê ·Éù·Éó·Éê·ÉÆ·Éò</p>
          <p>·É®·Éî·Éì·Éò ·Éù·Éó·Éê·ÉÆ·É®·Éò ·Éì·Éê ·É®·Éî·Éê·Éõ·Éù·É¨·Éõ·Éî</p>
        </div>
      `;
      roomCount.textContent = '·Éù·Éó·Éê·ÉÆ·Éî·Éë·Éò: 0';
      totalItems.textContent = '·É°·É£·Éö ·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò: 0';
      return;
    }
    
    roomCount.textContent = `·Éù·Éó·Éê·ÉÆ·Éî·Éë·Éò: ${summaries.length}`;
    totalItems.textContent = `·É°·É£·Éö ·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò: ${totalProducts}`;
    
    summaries.forEach(item => {
      const roomItem = document.createElement('div');
      const statusClass = item.status === 'green' ? 'green' : item.status === 'red' ? 'red' : '';
      roomItem.className = `inventory-room-item ${statusClass}`;
      roomItem.setAttribute('data-room', item.room);
      
      const productItemsHTML = item.products.map(product => 
        `<span class="product-item ${product.isYellow ? 'yellow-product' : ''}">${product.count} ${product.name}</span>`
      ).join('');
      
      const lastUpdated = new Date(item.lastUpdated);
      const timeAgo = getTimeAgo(lastUpdated);
      
      let feedbackText = '';
      
      roomItem.innerHTML = `
        <div class="swipe-feedback">${feedbackText}</div>
        <div class="swipe-progress"></div>
        <div class="inventory-room-header">
          <span class="room-number">
            ${item.status === 'green' ? '<span class="checkmark">‚úì</span>' : ''}
            ·Éù·Éó·Éê·ÉÆ·Éò ${item.room}
            ${currentSort !== 'date' ? `<span class="sort-indicator">${getSortIndicator()}</span>` : ''}
          </span>
        </div>
        <div class="room-summary">
          <div class="product-list">
            ${productItemsHTML}
          </div>
          <div class="last-updated">
            üïí ${timeAgo} ‚Ä¢ ·É°·É£·Éö: ${item.totalCount} ·Éû·É†·Éù·Éì·É£·É•·É¢·Éò
          </div>
        </div>
      `;
      
      addSwipeEvents(roomItem, item.room);
      inventoryList.appendChild(roomItem);
    });
  }
  
  function getSortIndicator() {
    switch(currentSort) {
      case 'room': return '·Éù·Éó·Éê·ÉÆ·Éò';
      case 'products': return '·É†·Éê·Éù·Éì·Éî·Éú·Éù·Éë·Éê';
      case 'date': return '·Éó·Éê·É†·Éò·É¶·Éò';
      default: return '';
    }
  }
  
  function getTimeAgo(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return '·Éê·ÉÆ·Éö·Éê';
    if (diffMins < 60) return `${diffMins} ·É¨·É£·Éó·Éò·É° ·É¨·Éò·Éú`;
    if (diffHours < 24) return `${diffHours} ·É°·Éê·Éê·Éó·Éò·É° ·É¨·Éò·Éú`;
    if (diffDays < 7) return `${diffDays} ·Éì·É¶·Éò·É° ·É¨·Éò·Éú`;
    return date.toLocaleDateString('ka-GE');
  }
  
  function addSwipeEvents(roomItem, roomNumber) {
    let touchStartX = 0;
    let touchEndX = 0;
    let touchStartY = 0;
    let touchEndY = 0;
    let touchStartTime = 0;
    let isSwiping = false;
    let swipeType = null;
    let isScrollEnabled = true; // Track if we should allow scrolling
    
    roomItem.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
      isSwiping = false;
      isScrollEnabled = true; // Reset scroll state
    });
    
    roomItem.addEventListener('touchmove', (e) => {
      if (!touchStartX) return;
      
      touchEndX = e.touches[0].clientX;
      touchEndY = e.touches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      // Check if it's a horizontal swipe (not vertical scroll)
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
        isSwiping = true;
        isScrollEnabled = false; // Disable scrolling during horizontal swipe
        e.preventDefault();
        
        const currentStatus = InventoryManager.isRoomMarked(roomNumber);
        
        if (deltaX > 0) {
          // Swipe right
          if (currentStatus === 'green') {
            swipeType = 'green';
            roomItem.classList.remove('swiping-red');
            roomItem.classList.add('swiping-green');
          } else {
            swipeType = 'red';
            roomItem.classList.remove('swiping-green');
            roomItem.classList.add('swiping-red');
          }
          
          const progress = Math.min(Math.abs(deltaX) / 150, 1);
          const progressBar = roomItem.querySelector('.swipe-progress');
          progressBar.style.width = `${progress * 100}%`;
          
          roomItem.style.transform = `translateX(${Math.min(deltaX * 0.5, 75)}px)`;
        } else {
          // Swipe left
          swipeType = 'undo';
          roomItem.classList.remove('swiping-red', 'swiping-green');
          
          const progress = Math.min(Math.abs(deltaX) / 150, 1);
          const progressBar = roomItem.querySelector('.swipe-progress');
          progressBar.style.width = `${progress * 100}%`;
          progressBar.style.background = '#94a3b8';
          
          roomItem.style.transform = `translateX(${Math.max(deltaX * 0.5, -75)}px)`;
        }
      } else if (isScrollEnabled) {
        // Allow vertical scrolling
        // Don't prevent default - let the browser handle scrolling
        return;
      }
    });
    
    roomItem.addEventListener('touchend', (e) => {
      if (!touchStartX) return;
      
      const touchDuration = Date.now() - touchStartTime;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const isTap = touchDuration < 250 && Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10;
      
      // Reset styles
      roomItem.classList.remove('swiping-red', 'swiping-green');
      roomItem.style.transform = '';
      
      const progressBar = roomItem.querySelector('.swipe-progress');
      progressBar.style.width = '0%';
      progressBar.style.background = '';
      
      // Handle swipe if it was a significant horizontal swipe
      if (isSwiping && Math.abs(deltaX) > 100) {
        e.preventDefault();
        
        if (deltaX > 0) {
          // Swipe right
          const currentStatus = InventoryManager.isRoomMarked(roomNumber);
          
          if (currentStatus === 'green') {
            // Already green, keep it green (no change)
            roomItem.classList.add('pulse');
            setTimeout(() => roomItem.classList.remove('pulse'), 300);
            showNotification(`·Éù·Éó·Éê·ÉÆ·Éò ${roomNumber} ·É£·Éô·Éï·Éî ·Éõ·Éù·Éú·Éò·É®·Éú·É£·Éö·Éò·Éê ‚úì`, '#10b981');
          } else if (currentStatus === 'red') {
            // Change from red to green
            InventoryManager.markRoom(roomNumber, 'green');
            roomItem.classList.remove('red');
            roomItem.classList.add('green');
            roomItem.classList.add('pulse');
            setTimeout(() => roomItem.classList.remove('pulse'), 300);
            showNotification(`·Éù·Éó·Éê·ÉÆ·Éò ${roomNumber} ·É®·Éî·Éï·É°·Éî·Éë·É£·Éö·Éò ·Éì·Éê ·Éê·É¶·É†·Éò·É™·ÉÆ·É£·Éö·Éò·Éê ‚úì`, '#10b981');
          } else {
            // No status, mark as red
            InventoryManager.markRoom(roomNumber, 'red');
            roomItem.classList.add('red');
            roomItem.classList.add('pulse');
            setTimeout(() => roomItem.classList.remove('pulse'), 300);
            showNotification(`·Éù·Éó·Éê·ÉÆ·Éò ${roomNumber} ·É®·Éî·Éï·É°·Éî·Éë·É£·Éö·Éò·Éê`, '#ef4444');
          }
        } else if (deltaX < 0) {
          // Swipe left - undo
          const currentStatus = InventoryManager.isRoomMarked(roomNumber);
          if (currentStatus) {
            InventoryManager.unmarkRoom(roomNumber);
            roomItem.classList.remove('green', 'red');
            roomItem.classList.add('pulse');
            setTimeout(() => roomItem.classList.remove('pulse'), 300);
            showNotification(`·Éù·Éó·Éê·ÉÆ·Éò ${roomNumber} ·Éõ·Éù·ÉÆ·É°·Éú·Éò·Éö·Éò·Éê`, '#3b82f6');
          }
        }
        
        setTimeout(() => {
          loadInventory();
        }, 500);
      } else if (isTap) {
        // It's a tap - do nothing
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Reset variables
      touchStartX = 0;
      touchStartY = 0;
      touchEndX = 0;
      touchEndY = 0;
      touchStartTime = 0;
      isSwiping = false;
      swipeType = null;
      isScrollEnabled = true;
    });
    
    // Allow scrolling on the inventory list container
    roomItem.addEventListener('touchmove', (e) => {
      // Allow vertical scrolling by not preventing default
      if (Math.abs(e.touches[0].clientY - touchStartY) > Math.abs(e.touches[0].clientX - touchStartX)) {
        // Vertical movement - allow scrolling
        return;
      }
    }, { passive: true });
    
    // Remove the click event handler that was preventing everything
    // roomItem.addEventListener('click', (e) => {
    //   // Allow regular clicking on desktop
    // });
  }
  
  function updateSortButton() {
    const sortNames = {
      'date': '·Éó·Éê·É†·Éò·É¶·Éò ',
      'room': '·Éù·Éó·Éê·ÉÆ·Éò ', 
      'products': '·É†·Éê·Éù·Éì·Éî·Éú·Éù·Éë·Éê '
    };
    sortButton.textContent = `·Éì·Éê·Éö·Éê·Éí·Éî·Éë·Éê: ${sortNames[currentSort]}`;
  }
  
  function cycleSortMethod() {
    sortIndex = (sortIndex + 1) % sortMethods.length;
    currentSort = sortMethods[sortIndex];
    localStorage.setItem('inventorySort', currentSort);
    updateSortButton();
    loadInventory();
    showNotification(`·Éì·Éê·Éö·Éê·Éí·Éî·Éë·Éê: ${getSortName(currentSort)}`, '#8b5cf6');
  }
  
  function getSortName(method) {
    const names = {
      'date': '·Éó·Éê·É†·Éò·É¶·Éò',
      'room': '·Éù·Éó·Éê·ÉÆ·Éò·É° ·Éú·Éù·Éõ·Éî·É†·Éò',
      'products': '·Éû·É†·Éù·Éì·É£·É•·É¢·Éî·Éë·Éò·É° ·É†·Éê·Éù·Éì·Éî·Éú·Éù·Éë·Éê'
    };
    return names[method] || method;
  }
  
  function showNotification(message, color = '#10b981') {
    const existingNotification = document.querySelector('.custom-notification');
    if (existingNotification) existingNotification.remove();
    
    const notification = document.createElement('div');
    notification.className = 'custom-notification';
    notification.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      background: ${color}20;
      color: ${color === '#10b981' ? '#a7f3d0' : color === '#ef4444' ? '#fecaca' : '#e9d5ff'};
      padding: 12px 20px;
      border-radius: 8px;
      border: 2px solid ${color}60;
      z-index: 1000;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideIn 0.3s ease;
    `;
    
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 2000);
  }
  
  clearButton.addEventListener('click', () => {
    if (confirm('·Éì·Éê·É†·É¨·Éõ·É£·Éú·Éî·Éë·É£·Éö·Éò ·ÉÆ·Éê·É†? ·Éß·Éï·Éî·Éö·Éê·É§·Éî·É†·Éò ·É¨·Éê·Éò·É®·Éö·Éî·Éë·Éê')) {
      InventoryManager.clearAll();
      loadInventory();
      showNotification('·Éß·Éï·Éî·Éö·Éê·É§·Éî·É†·Éò ·É¨·Éê·É®·Éö·Éò·Éö·Éò·Éê', '#ef4444');
    }
  });
  
  exportButton.addEventListener('click', () => {
    InventoryManager.exportInventory();
    showNotification('·Éò·Éú·Éï·Éî·Éú·É¢·Éê·É†·Éò ·Éî·É•·É°·Éû·Éù·É†·É¢·Éò·É†·Éî·Éë·É£·Éö·Éò·Éê', '#3b82f6');
  });
  
  sortButton.addEventListener('click', cycleSortMethod);
  
  loadInventory();
  setInterval(loadInventory, 10000);
});
</script>
<script>
// Add this to prevent double-tap zoom on ALL pages
document.addEventListener('DOMContentLoaded', function() {
  // Method 1: Prevent zoom on double tap
  let lastTouchEnd = 0;
  
  document.addEventListener('touchend', function(event) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
  
  // Method 2: Prevent zoom gestures
  document.addEventListener('gesturestart', function(event) {
    event.preventDefault();
  });
  
  // Method 3: Prevent multiple touch zoom
  document.addEventListener('touchstart', function(event) {
    if (event.touches.length > 1) {
      event.preventDefault();
    }
  }, { passive: false });
  
  // Method 4: Disable zoom completely on iOS
  document.addEventListener('touchmove', function(event) {
    if (event.scale !== 1) {
      event.preventDefault();
    }
  }, { passive: false });
});
</script>
</body>
</html>